## ğŸ’¡ TIL: Singleton íŒ¨í„´ in Java â˜•

### ğŸ˜¥ ë¬¸ì œì  (Problems)

*   **í…ŒìŠ¤íŠ¸í•˜ê¸° ì–´ë ¤ì›€ (Hard to Test):** ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ëŠ” ì „ì—­ì ìœ¼ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì—, ê²©ë¦¬ëœ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. Mock ê°ì²´ë¡œ ëŒ€ì²´í•˜ê±°ë‚˜, ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ê²ƒì´ ë²ˆê±°ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    ```java
    // ì‹±ê¸€í†¤ì„ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤
    public class MyService {
        private static final MyService instance = new MyService();
        private MyService() {}
        public static MyService getInstance() {
            return instance;
        }
        public String getData() {
            // ...
            return "data";
        }
    }

    // í…ŒìŠ¤íŠ¸ ì½”ë“œ (ì–´ë ¤ì›€)
    // MyServiceì˜ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ Mockìœ¼ë¡œ ëŒ€ì²´í•˜ê¸° ì–´ë µë‹¤.
    ```

*   **ì˜ì¡´ì„± ë¬¸ì œ (Dependency Issue):** ì‹±ê¸€í†¤ì€ ì „ì—­ ìƒíƒœë¥¼ ê°€ì§€ê¸° ì‰½ê³ , ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ì„œ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ê°•í•œ ê²°í•©ì´ ë°œìƒí•©ë‹ˆë‹¤. ì´ëŠ” ì½”ë“œì˜ ìœ ì—°ì„±ì„ ë–¨ì–´ëœ¨ë¦¬ê³ , ìœ ì§€ë³´ìˆ˜ë¥¼ ì–´ë µê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    ```java
    public class ClientClass {
        public void doSomething() {
            MyService service = MyService.getInstance(); // ê°•í•œ ê²°í•©
            String data = service.getData();
            // ...
        }
    }
    ```

*   **ë™ì‹œì„± ë¬¸ì œ (Concurrency Issue):** ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ì— ì ‘ê·¼í•˜ëŠ” ê²½ìš°, ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ê°€ë³€ ìƒíƒœë¥¼ ê°€ì§€ëŠ” ê²½ìš°, race conditionì´ë‚˜ deadlockê³¼ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    ```java
    public class SingletonCounter {
        private static SingletonCounter instance = null;
        private int count = 0;

        private SingletonCounter() {}

        public static SingletonCounter getInstance() {
            if (instance == null) { // race condition ë°œìƒ ê°€ëŠ¥
                instance = new SingletonCounter();
            }
            return instance;
        }

        public void increment() {
            count++; // ë™ì‹œì„± ë¬¸ì œ ë°œìƒ ê°€ëŠ¥
        }

        public int getCount() {
            return count;
        }
    }
    ```

*   **ê°ì²´ì§€í–¥ ì›ì¹™ ìœ„ë°˜ (Violation of OOP Principles):** ì‹±ê¸€í†¤ íŒ¨í„´ì€ SOLID ì›ì¹™ ì¤‘ ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP)ê³¼ ê°œë°©-íì‡„ ì›ì¹™(OCP)ì„ ìœ„ë°˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹±ê¸€í†¤ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§€ê±°ë‚˜, ë³€ê²½ì— ë‹«í˜€ìˆê³  í™•ì¥ì— ì—´ë ¤ìˆì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### âœ… í•´ê²°ë²• (Solutions)

*   **ì¸í„°í˜ì´ìŠ¤ì™€ ì˜ì¡´ì„± ì£¼ì… (Interface and Dependency Injection):** ì‹±ê¸€í†¤ í´ë˜ìŠ¤ë¥¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ì¶”ìƒí™”í•˜ê³ , ì˜ì¡´ì„± ì£¼ì… (Dependency Injection, DI) ì»¨í…Œì´ë„ˆë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì£¼ì…í•˜ë©´ í…ŒìŠ¤íŠ¸ ìš©ì´ì„±ì„ ë†’ì´ê³ , ê²°í•©ë„ë¥¼ ë‚®ì¶œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    ```java
    public interface Service {
        String getData();
    }

    public class MyService implements Service {
        private static final MyService instance = new MyService();
        private MyService() {}
        public static MyService getInstance() {
            return instance;
        }
        public String getData() {
            // ...
            return "data";
        }
    }

    public class ClientClass {
        private Service service; // ì¸í„°í˜ì´ìŠ¤ ì˜ì¡´

        // DI ì»¨í…Œì´ë„ˆë¥¼ í†µí•´ ì£¼ì…
        public ClientClass(Service service) {
            this.service = service;
        }

        public void doSomething() {
            String data = service.getData();
            // ...
        }
    }
    ```

*   **Lazy Initialization ê³¼ Double-Checked Locking:**  ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í•„ìš”í•  ë•Œ ìƒì„±í•˜ëŠ” Lazy Initializationì„ ì‚¬ìš©í•˜ê³ , Double-Checked Lockingê³¼ ê°™ì€ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ Double-Checked Lockingì€ Java ë²„ì „ ë° í™˜ê²½ì— ë”°ë¼ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. (ë” ì•ˆì „í•œ ë°©ë²•ìœ¼ë¡œëŠ” static inner classë¥¼ í™œìš©í•œ initialization-on-demand holder patternì´ ìˆìŠµë‹ˆë‹¤.)

    ```java
    public class SingletonCounter {
        private static volatile SingletonCounter instance = null; // volatile í‚¤ì›Œë“œ ì‚¬ìš©
        private int count = 0;

        private SingletonCounter() {}

        public static SingletonCounter getInstance() {
            if (instance == null) {
                synchronized (SingletonCounter.class) { // synchronized ë¸”ë¡ ì‚¬ìš©
                    if (instance == null) { // double-checked locking
                        instance = new SingletonCounter();
                    }
                }
            }
            return instance;
        }

        public void increment() {
            count++;
        }

        public int getCount() {
            return count;
        }
    }
    ```

*   **ì‹±ê¸€í†¤ ëŒ€ì‹  ë‹¤ë¥¸ ë””ìì¸ íŒ¨í„´ ê³ ë ¤ (Consider Alternatives):**  ì‹±ê¸€í†¤ íŒ¨í„´ì´ ì •ë§ í•„ìš”í•œ ìƒí™©ì¸ì§€ ë‹¤ì‹œ í•œë²ˆ ê³ ë¯¼í•´ë³´ê³ , íŒ©í† ë¦¬ íŒ¨í„´, ë¹Œë” íŒ¨í„´, í”„ë¡œí† íƒ€ì… íŒ¨í„´ ë“± ë‹¤ë¥¸ ë””ìì¸ íŒ¨í„´ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ”ì§€ ê³ ë ¤í•´ë´…ë‹ˆë‹¤. ë•Œë¡œëŠ” ì‹±ê¸€í†¤ íŒ¨í„´ ëŒ€ì‹  static utility classë‚˜ plain objectë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì€ í•´ê²°ì±…ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ğŸ¤” ìƒê°í•  ì  (Things to Consider)

*   **ë‚¨ìš©í•˜ì§€ ì•Šê¸° (Avoid Overuse):** ì‹±ê¸€í†¤ íŒ¨í„´ì€ ì „ì—­ ìƒíƒœë¥¼ ë§Œë“¤ê³  ì½”ë“œì˜ ê²°í•©ë„ë¥¼ ë†’ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ê¼­ í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë¬´ë¶„ë³„í•œ ì‹±ê¸€í†¤ ì‚¬ìš©ì€ ì½”ë“œ ìœ ì§€ë³´ìˆ˜ë¥¼ ì–´ë µê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*   **ìƒíƒœ ê´€ë¦¬ (State Management):** ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒíƒœë¥¼ ê°€ì§€ëŠ” ê²½ìš°, ìƒíƒœ ê´€ë¦¬ì— ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. íŠ¹íˆ ì—¬ëŸ¬ ê³³ì—ì„œ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ê²½ìš°, ì˜ˆê¸°ì¹˜ ì•Šì€ side effectê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤ë©´ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ëŠ” statelessí•˜ê²Œ ì„¤ê³„í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
*   **ì „ì—­ ì ‘ê·¼ì˜ í•„ìš”ì„± ì¬ê³  (Reconsider Global Access):** ì •ë§ë¡œ ì „ì—­ì ì¸ ì ‘ê·¼ì´ í•„ìš”í•œì§€ ë‹¤ì‹œ í•œë²ˆ ìƒê°í•´ë³´ê³ , ì‹±ê¸€í†¤ íŒ¨í„´ ëŒ€ì‹  ë” ë‚˜ì€ ëŒ€ì•ˆì´ ìˆëŠ”ì§€ ê³ ë¯¼í•´ë´…ë‹ˆë‹¤. ë•Œë¡œëŠ” ê°ì²´ë¥¼ ìƒì„±í•˜ê³  í•„ìš”í•œ ê³³ì— íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•˜ëŠ” ê²ƒì´ ë” ê°ì²´ì§€í–¥ì ì¸ í•´ê²°ì±…ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


## ğŸ’¡ ì‹±ê¸€í†¤ íŒ¨í„´ ì˜ˆì‹œì™€ ì¶”ê°€ ì„¤ëª… 

### ğŸ“š ì‹±ê¸€í†¤ íŒ¨í„´ì´ë€? (What is Singleton Pattern?)

ì‹±ê¸€í†¤ íŒ¨í„´ì€ **í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë‹¨ í•˜ë‚˜ë§Œ ë§Œë“¤ê³ **, ê·¸ ì¸ìŠ¤í„´ìŠ¤ì— **ì–´ë””ì„œë“  ì ‘ê·¼**í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë””ìì¸ íŒ¨í„´ì…ë‹ˆë‹¤. ë§ˆì¹˜ **ì„¸ìƒì— í•˜ë‚˜ë¿ì¸** ì¡´ì¬ì²˜ëŸ¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ì£ ! ğŸ”‘

**ì™œ ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì‚¬ìš©í• ê¹Œìš”?**

*   **ìì› ê´€ë¦¬ íš¨ìœ¨ì„±:**  DB ì»¤ë„¥ì…˜ í’€, ë¡œê¹…, ì„¤ì • ê´€ë¦¬ìì²˜ëŸ¼ **í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤**ë§Œìœ¼ë¡œ **ì „ì—­ì ìœ¼ë¡œ** ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ìì›ì— ìœ ìš©í•©ë‹ˆë‹¤. ë§¤ë²ˆ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ëŒ€ì‹  **í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ **í•˜ì—¬ ë©”ëª¨ë¦¬ ë‚­ë¹„ë¥¼ ì¤„ì´ê³  íš¨ìœ¨ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*   **ì „ì—­ì ì¸ ì ‘ê·¼ì  ì œê³µ:**  ì–´í”Œë¦¬ì¼€ì´ì…˜ ì–´ë””ì—ì„œë“  **ì‰½ê²Œ ì ‘ê·¼**í•  ìˆ˜ ìˆëŠ” **ë‹¨ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤**ë¥¼ ì œê³µí•˜ì—¬ **ì „ì—­ ìƒíƒœ**ë¥¼ ê´€ë¦¬í•˜ê³  ê³µìœ í•˜ëŠ”ë° í¸ë¦¬í•©ë‹ˆë‹¤.

### âš™ï¸ 1. ì„¤ì • ê´€ë¦¬ì (Configuration Manager)

ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„¤ì •ì„ ë‹´ë‹¹í•˜ëŠ” `AppConfig` ì‹±ê¸€í†¤ í´ë˜ìŠ¤ ì˜ˆì‹œì…ë‹ˆë‹¤. DB ì—°ê²° URL, API í‚¤ì™€ ê°™ì€ ì„¤ì • ì •ë³´ë¥¼ ì „ì—­ì ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

```java
public class AppConfig {

    private static AppConfig instance = null;
    private String databaseUrl;
    private String apiKey;

    private AppConfig() {
        // ì„¤ì • íŒŒì¼ ë˜ëŠ” ì™¸ë¶€ ì†ŒìŠ¤ì—ì„œ ì„¤ì • ë¡œë“œ (ì˜ˆì‹œ)
        this.databaseUrl = loadConfig("database.url");
        this.apiKey = loadConfig("api.key");
    }

    public static AppConfig getInstance() {
        if (instance == null) {
            instance = new AppConfig();
        }
        return instance;
    }

    public String getDatabaseUrl() {
        return databaseUrl;
    }

    public String getApiKey() {
        return apiKey;
    }

    private String loadConfig(String key) {
        // ì‹¤ì œ ì„¤ì • ë¡œë”© ë¡œì§ (properties íŒŒì¼, í™˜ê²½ ë³€ìˆ˜ ë“±)
        // ì˜ˆì‹œ: ê°„ë‹¨í•˜ê²Œ í•˜ë“œì½”ë”©
        if (key.equals("database.url")) {
            return "jdbc://localhost:3306/mydb";
        } else if (key.equals("api.key")) {
            return "your_api_key";
        }
        return null;
    }
}
```
```java
//ì‚¬ìš©ì˜ˆì‹œ
public class DBConnection {
    public void connect() {
        AppConfig config = AppConfig.getInstance();
        String dbUrl = config.getDatabaseUrl();
        // dbUrlì„ ì‚¬ìš©í•˜ì—¬ DB ì—°ê²°
        System.out.println("Connecting to DB: " + dbUrl);
    }
}

public class ApiClient {
    public void callApi() {
        AppConfig config = AppConfig.getInstance();
        String apiKey = config.getApiKey();
        // apiKeyë¥¼ ì‚¬ìš©í•˜ì—¬ API í˜¸ì¶œ
        System.out.println("Using API Key: " + apiKey);
    }
}
```
> DBConnectionê³¼ ApiClientëŠ” AppConfig.getInstance()ë¥¼ í†µí•´ ë™ì¼í•œ ì„¤ì • ì •ë³´ë¥¼ ê³µìœ í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.

### ğŸªµ2. ë¡œê±° (Logger)
- ì–´í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ ë¡œê·¸ë¥¼ ê¸°ë¡í•˜ëŠ” Logger ì‹±ê¸€í†¤ í´ë˜ìŠ¤ ì˜ˆì‹œì…ë‹ˆë‹¤.
``` java
public class Logger {

    private static Logger instance = null;
    private Logger() {} // private ìƒì„±ì

    public static Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }

    public void log(String message) {
        // ì‹¤ì œ ë¡œê¹… ë¡œì§ (íŒŒì¼, ì½˜ì†”, DB ë“±)
        System.out.println("[Log] " + message);
    }

    public void error(String message, Exception e) {
        // ì—ëŸ¬ ë¡œê·¸ ë¡œì§
        System.err.println("[Error] " + message + ", Exception: " + e);
    }
}
```
```java
//ì‚¬ìš©ì˜ˆì‹œ
public class MyService {
    public void processData(String data) {
        Logger logger = Logger.getInstance();
        logger.log("Data processing started: " + data);
        try {
            // ë°ì´í„° ì²˜ë¦¬ ë¡œì§
            if (data == null) {
                throw new IllegalArgumentException("Data cannot be null");
            }
            System.out.println("Processed data: " + data);
        } catch (Exception e) {
            logger.error("Error processing data", e);
        }
        logger.log("Data processing finished");
    }
}
```
> MyService í´ë˜ìŠ¤ëŠ” Logger.getInstance()ë¥¼ í†µí•´ ë¡œê±°ë¥¼ ì–»ì–´ì™€ ë¡œê·¸ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œë„ Logger.getInstance()ë¥¼ í˜¸ì¶œí•˜ë©´ í•­ìƒ ê°™ì€ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¼ê´€ëœ ë¡œê·¸ë¥¼ ë‚¨ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ğŸ—„ï¸3. DBì»¤ë„¥ì…˜ í’€
- DB ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” ConnectionPool ì‹±ê¸€í†¤ í´ë˜ìŠ¤ ì˜ˆì‹œì…ë‹ˆë‹¤. ì œí•œëœ DB ì—°ê²° ìì›ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ê³µìœ í•©ë‹ˆë‹¤.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class ConnectionPool {

    private static ConnectionPool instance = null;
    private List<Connection> connections;
    private static final int MAX_CONNECTIONS = 5; // ìµœëŒ€ ì»¤ë„¥ì…˜ ê°œìˆ˜

    private ConnectionPool() {
        connections = new ArrayList<>();
        try {
            // ì´ˆê¸° ì»¤ë„¥ì…˜ ìƒì„±
            for (int i = 0; i < MAX_CONNECTIONS; i++) {
                connections.add(createConnection());
            }
        } catch (SQLException e) {
            System.err.println("Failed to initialize connection pool: " + e);
        }
    }

    public static ConnectionPool getInstance() {
        if (instance == null) {
            instance = new ConnectionPool();
        }
        return instance;
    }

    private Connection createConnection() throws SQLException {
        // DB ì—°ê²° ìƒì„± ë¡œì§ (ì˜ˆì‹œ)
        String url = AppConfig.getInstance().getDatabaseUrl(); // ì„¤ì • ì •ë³´ ì‚¬ìš©
        return DriverManager.getConnection(url, "username", "password");
    }

    public Connection getConnection() {
        if (connections.isEmpty()) {
            try {
                return createConnection(); // ì»¤ë„¥ì…˜ ë¶€ì¡± ì‹œ ìƒˆë¡œ ìƒì„± (ë˜ëŠ” ëŒ€ê¸°/ì—ëŸ¬ ì²˜ë¦¬)
            } catch (SQLException e) {
                System.err.println("Failed to create new connection: " + e);
                return null; // ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš”
            }
        }
        return connections.remove(0); // í’€ì—ì„œ ì»¤ë„¥ì…˜ ê°€ì ¸ì˜¤ê¸°
    }

    public void releaseConnection(Connection connection) {
        if (connection != null) {
            connections.add(connection); // ì‚¬ìš© í›„ ì»¤ë„¥ì…˜ í’€ì— ë°˜í™˜
        }
    }
}
```
```java
//ì‚¬ìš©ì˜ˆì‹œ
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

public class DataProcessor {
    public void processData() {
        ConnectionPool pool = ConnectionPool.getInstance();
        Connection connection = pool.getConnection(); // ì»¤ë„¥ì…˜ í’€ì—ì„œ ì»¤ë„¥ì…˜ íšë“
        if (connection != null) {
            try (Statement statement = connection.createStatement()) {
                // DB ì‘ì—… ìˆ˜í–‰
                statement.executeQuery("SELECT * FROM my_table");
                // ...
            } catch (SQLException e) {
                System.err.println("DB error: " + e);
            } finally {
                pool.releaseConnection(connection); // ì‚¬ìš© í›„ ì»¤ë„¥ì…˜ í’€ì— ë°˜í™˜ (finally ë¸”ë¡ì—ì„œ!)
            }
        }
    }
}
```