### 1. HTTP 프로토콜 심층 이해

- **HTTP (Hypertext Transfer Protocol)란?**

  - 웹 브라우저와 웹 서버 간에 데이터를 주고받기 위한 **통신 규약**입니다.
  - **클라이언트-서버 모델을 기반**으로 동작합니다. (클라이언트: 웹 브라우저, 서버: 웹 서버)
  - 텍스트 기반의 프로토콜로, 사람이 읽고 이해하기 쉽습니다.
  - TCP/IP 프로토콜 위에서 동작하며, 기본 포트 번호는 80번입니다. (HTTPS는 443번)

- **HTTP의 중요성**

  - 오늘날 웹의 기반이 되는 핵심 프로토콜입니다.
  - 웹 페이지, 이미지, 비디오 등 **다양한 형태의 데이터를 전송**하는 데 사용됩니다.
  - **RESTful API 개발의 핵심 기술**입니다.

- **HTTP 작동 방식 (요청-응답 사이클)**

  1.  **요청 (Request):** 클라이언트 (웹 브라우저)가 서버에 특정 작업을 요청합니다. 요청 메시지는 다음과 같은 정보를 포함합니다.
      - **HTTP 메서드:** 수행하고자 하는 동작 (GET, POST 등)
      - **요청 URI (Uniform Resource Identifier):** 접근하고자 하는 자원의 주소
      - **HTTP 버전:** 사용하고 있는 HTTP 프로토콜 버전
      - **요청 헤더:** 요청에 대한 추가 정보 (예: 브라우저 정보, 허용 가능한 데이터 형식 등)
      - **요청 본문 (선택 사항):** POST, PUT 등의 메서드에서 전송하는 데이터
  2.  **응답 (Response):** 서버가 클라이언트의 요청을 처리한 후 결과를 응답합니다. 응답 메시지는 다음과 같은 정보를 포함합니다.
      - **HTTP 버전:** 사용하고 있는 HTTP 프로토콜 버전
      - **상태 코드:** 요청 처리 결과 (200 OK, 404 Not Found 등)
      - **응답 헤더:** 응답에 대한 추가 정보 (예: 서버 정보, 응답 데이터 형식 등)
      - **응답 본문 (선택 사항):** 요청한 자원 데이터 (HTML, 이미지 등)

- **HTTP 메서드 심층 분석**

  - HTTP 메서드는 클라이언트가 서버에게 수행하고자 하는 동작을 명시하는 데 사용됩니다. 주요 메서드는 다음과 같습니다.
    - **GET:** 서버로부터 특정 자원을 **요청**합니다.
      - **주로 데이터를 조회**하는 데 사용됩니다.
      - 요청 파라미터는 URL에 포함되어 전송됩니다. (쿼리 스트링)
      - 멱등성을 가집니다. (동일한 요청을 여러 번 보내도 결과가 같습니다.)
      - 데이터를 서버에 변경을 일으키지 않아야 합니다.
      - 브라우저 캐싱이 가능합니다.
    - **POST:** 서버에 데이터를 **전송**하여 새로운 자원을 **생성**하거나, 기존 자원을 **업데이트**하거나, 데이터를 처리하는 데 사용됩니다.
      - 요청 파라미터는 요청 본문에 포함되어 전송됩니다.
      - 멱등성을 가지지 않습니다. (동일한 요청을 여러 번 보내면 서버 상태가 변경될 수 있습니다.)
      - **주로 폼 데이터 전송, 파일 업로드 등**에 사용됩니다.
    - **PUT:** 서버에 데이터를 **전송**하여 특정 URI에 해당하는 자원을 **생성**하거나 **대체**합니다.
      - 특정 자원을 지정하여 완전히 새로운 내용으로 **덮어쓰는 개념**입니다.
      - 멱등성을 가집니다. (동일한 요청을 여러 번 보내도 결과가 같습니다.)
    - **DELETE:** 서버에 **요청**하여 특정 URI에 해당하는 자원을 **삭제**합니다.
      - 멱등성을 가집니다. (동일한 요청을 여러 번 보내도 결과가 같습니다. 처음 삭제 성공 후에는 해당 자원이 없다는 응답을 받게 됩니다.)
    - HEAD: GET 메서드와 동일하지만, 응답 본문을 포함하지 않고 **헤더 정보만** 요청합니다.
      - 서버의 상태나 자원의 존재 유무, 변경 여부 등을 확인하는 데 유용합니다.
    - OPTIONS: 서버가 특정 URI에 대해 지원하는 HTTP 메서드 목록을 **요청**합니다.
      - CORS (Cross-Origin Resource Sharing) preflight 요청 등에 사용됩니다.
    - PATCH: 서버에 데이터를 **전송**하여 특정 URI에 해당하는 자원의 **일부분을 수정**합니다.
      - PUT과 달리 자원의 전체를 덮어쓰는 것이 아니라, 특정 필드만 업데이트하는 데 사용됩니다.

- **HTTP 상태 코드 활용 방법**

  - HTTP 상태 코드는 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 세 자리 숫자 코드입니다.
    - 1xx (Informational): 요청이 수신되어 **처리 중임**을 나타냅니다. **(거의 사용되지 않음)**
    - 2xx (Success): 요청이 **성공적으로 처리**되었음을 나타냅니다.
      - 200 OK: 요청이 성공적으로 처리되었으며, 요청한 정보가 응답에 포함되어 있습니다. (가장 일반적인 성공 응답)
      - 201 Created: 요청이 성공적으로 처리되었으며, 새로운 자원이 생성되었습니다. (주로 POST 요청에 대한 응답)
      - 204 No Content: 요청이 성공적으로 처리되었지만, 응답 본문에 포함할 내용이 없습니다. (주로 DELETE 요청에 대한 응답)
    - 3xx (Redirection): 요청한 자원이 **다른 위치로 이동**되었음을 나타냅니다.
      - 301 Moved Permanently: 요청한 자원이 영구적으로 새로운 URI로 이동되었습니다. (검색 엔진 최적화에 중요)
      - 302 Found (Temporary Redirect): 요청한 자원이 일시적으로 다른 URI로 이동되었습니다.
      - 304 Not Modified: 클라이언트가 캐시한 자원을 사용해도 된다는 응답입니다. (조건부 GET 요청에 대한 응답)
    - **4xx (Client Error):** **클라이언트 측의 오류**로 인해 요청을 처리할 수 없음을 나타냅니다.
      - **400 Bad Request:** 클라이언트의 요청 구문이 잘못되었거나 유효하지 않습니다.
      - **401 Unauthorized:** 요청한 자원에 접근하기 위한 인증이 필요합니다.
      - **403 Forbidden:** 서버가 클라이언트의 요청을 거부합니다. (권한 부족 등)
      - **404 Not Found:** 요청한 URI에 해당하는 자원을 찾을 수 없습니다.
    - **5xx (Server Error):** **서버 측의 오류**로 인해 요청을 처리할 수 없음을 나타냅니다.
      - **500 Internal Server Error:** 서버 내부 오류가 발생하여 요청을 처리할 수 없습니다. (일반적인 서버 오류)
      - **503 Service Unavailable:** 서버가 일시적으로 요청을 처리할 수 없습니다. (서버 과부하, 점검 등)
  - 상태 코드 활용 방법:
    - 클라이언트는 응답 상태 코드를 통해 요청 처리 결과를 파악하고, 적절한 후속 조치를 취할 수 있습니다.
    - API 개발 시 명확하고 의미 있는 상태 코드를 사용하여 클라이언트에게 오류 상황을 효과적으로 전달할 수 있습니다.
    - 로그 분석 등을 통해 서버의 상태를 모니터링하고 문제를 진단하는 데 활용할 수 있습니다.

- **HTTP 헤더 및 쿠키 활용 방법**

  - **HTTP 헤더:** HTTP 요청 및 응답 메시지에 포함되어 추가적인 정보를 제공합니다.
    - **요청 헤더 (Request Headers):** 클라이언트가 서버에게 보내는 요청에 대한 정보
      - `User-Agent`: 클라이언트의 브라우저 및 운영체제 정보
      - `Content-Type`: 요청 본문의 데이터 형식 (예: `application/json`, `application/x-www-form-urlencoded`)
      - `Accept`: 서버가 응답할 수 있는 데이터 형식 목록
      - `Authorization`: 서버에 대한 인증 정보를 포함 (예: Bearer 토큰)
      - `Cookie`: 서버가 이전에 설정한 쿠키 정보를 포함
    - **응답 헤더 (Response Headers):** 서버가 클라이언트에게 보내는 응답에 대한 정보
      - `Content-Type`: 응답 본문의 데이터 형식
      - `Content-Length`: 응답 본문의 크기
      - `Set-Cookie`: 클라이언트에게 쿠키를 설정하도록 지시
      - `Server`: 서버 소프트웨어 정보
      - `Cache-Control`: 캐싱 정책을 설정
  - **쿠키 (Cookies):** 서버가 **클라이언트의 웹 브라우저에 저장하는** 작은 텍스트 파일입니다.

    - **쿠키의 역할:** HTTP는 무상태(Stateless) 프로토콜이기 때문에, 클라이언트의 이전 요청을 기억하지 못합니다. 쿠키는 이러한 한계를 극복하고 상태를 유지하는 데 사용됩니다.
    - **주요 활용 사례:**

      - **세션 관리:** 사용자 로그인 상태 유지
      - **개인화:** 사용자 설정, 테마, 선호도 저장
      - **트래킹:** 사용자 행동 분석, 광고 타겟팅

    - **쿠키 동작 방식:**

      1.  서버가 HTTP 응답 헤더에 `Set-Cookie`를 포함하여 클라이언트에게 쿠키를 전송합니다.
      2.  클라이언트 (웹 브라우저)는 받은 쿠키를 저장합니다.
      3.  이후 클라이언트가 동일한 서버에 요청을 보낼 때, HTTP 요청 헤더에 `Cookie`를 포함하여 저장된 쿠키를 함께 전송합니다.
      4.  서버는 받은 쿠키 정보를 통해 클라이언트의 상태를 파악합니다.

    - **쿠키 속성:**
      - `Name`: 쿠키의 이름
      - `Value`: 쿠키의 값
      - `Expires` 또는 `Max-Age`: 쿠키의 만료일 또는 유효 시간
      - `Domain`: 쿠키가 유효한 도메인
      - `Path`: 쿠키가 유효한 경로
      - `Secure`: HTTPS 연결에서만 쿠키를 전송할지 여부
      - `HttpOnly`: JavaScript에서 쿠키에 접근할 수 있는지 여부 (보안 강화)

- **예상 질문 및 답변**

  - **1. GET과 POST 메서드의 차이점은 무엇인가요?**
    ```
    | 특징        | GET                                  | POST                                     |
    | ----------- | ------------------------------------ | ---------------------------------------- |
    | 주요 목적     | 서버로부터 자원 요청 및 조회             | 서버에 데이터 전송하여 자원 생성/수정/처리 |
    | 데이터 전송   | URL 파라미터 (쿼리 스트링)             | 요청 본문 (Body)                         |
    | 보안        | 상대적으로 낮음 (URL에 데이터 노출 가능) | 상대적으로 높음 (본문에 데이터 숨김)      |
    | 캐싱        | 브라우저 캐싱 가능                     | 일반적으로 캐싱되지 않음                 |
    | 멱등성      | 있음 (여러 번 요청해도 결과가 동일)      | 없음 (여러 번 요청 시 서버 상태 변경 가능) |
    | 길이 제한    | URL 길이 제한 있음                      | 일반적으로 길이 제한 없음                   |
    | 주요 사용 사례 | 데이터 조회, 검색, 링크 이동             | 폼 전송, 파일 업로드, 데이터 생성/수정      |
    ```
  - **2. HTTP 상태 코드 500과 503의 차이점은 무엇인가요?**

    - **500 Internal Server Error:** 서버 내부에서 예기치 않은 오류가 발생하여 요청을 처리할 수 없는 상황입니다. 이는 서버의 코드 오류, 설정 문제 등 다양한 원인으로 발생할 수 있습니다. 일반적으로 클라이언트 측의 재시도로 해결되지 않을 가능성이 높습니다.
    - **503 Service Unavailable:** 서버가 일시적으로 요청을 처리할 수 없는 상황입니다. 이는 서버 과부하, 서버 점검, 네트워크 문제 등으로 인해 발생할 수 있습니다. 일정 시간 후 클라이언트가 재시도하면 정상적으로 처리될 수 있습니다. `Retry-After` 응답 헤더를 통해 언제 다시 요청해야 하는지 힌트를 제공하기도 합니다.
    - **핵심 차이:** 500은 서버 내부의 **예상치 못한 오류**이고, 503은 서버가 **일시적으로 사용 불가능**한 상황입니다.

  - **3. 쿠키와 세션의 차이점은 무엇이며, 어떤 상황에서 사용해야 하나요?**

    ```
    | 특징        | 쿠키 (Cookie)                                  | 세션 (Session)                                      |
    | ----------- | --------------------------------------------- | --------------------------------------------------- |
    | 저장 위치     | 클라이언트 (웹 브라우저)                       | 서버                                                |
    | 보안        | 상대적으로 낮음 (클라이언트에서 내용 확인 및 수정 가능) | 상대적으로 높음 (서버에서 관리)                       |
    | 만료 시점     | 명시적으로 설정 (브라우저 종료와 무관하게 유지 가능) | 일반적으로 브라우저 종료 시 만료 (설정에 따라 다름) |
    | 저장 용량     | 제한적 (브라우저마다 다름)                     | 서버 용량에 따라 다름                               |
    | 사용 목적     | 사용자 인증 상태 유지, 개인 설정 저장, 트래킹 등 | 사용자 인증 상태 유지 (로그인 정보 등)                |
    ```

    - **사용 상황:**
      - **쿠키:** 사용자 설정을 저장하고 싶을 때 (예: 테마, 글꼴 크기), 간단한 사용자 식별 및 트래킹이 필요할 때, 장바구니 정보 등 비교적 덜 중요한 데이터를 클라이언트에 저장하고 싶을 때
      - **세션:** 사용자 로그인 상태와 같이 보안이 중요한 정보를 관리해야 할 때, 개별 사용자의 상태를 서버 측에서 안전하게 유지하고 싶을 때, 쿠키에 저장하기에는 용량이 크거나 민감한 데이터를 다룰 때
    - **핵심 차이:** 쿠키는 클라이언트에 데이터를 저장하는 반면, 세션은 서버에 데이터를 저장하고 클라이언트에는 세션 ID만 쿠키를 통해 전달하여 상태를 유지합니다. 보안 측면에서는 세션이 더 안전합니다.

  - **4. HTTP/3는 HTTP/2에 비해 어떠한 장점이 있는가?**
    - **기본 전송 계층으로 QUIC 프로토콜 사용:** HTTP/2는 TCP 기반, HTTP/3는 UDP 기반의 QUIC 사용으로 Head-of-Line Blocking 문제 해결.
    - **향상된 연결 설정 속도:** QUIC은 TCP와 TLS 핸드셰이크 결합으로 초기 연결 시간 단축.
    - **개선된 스트림 멀티플렉싱:** QUIC은 연결 자체가 아닌 개별 스트림 레벨에서 독립적인 흐름 제어 제공.
    - **향상된 보안:** QUIC은 TLS 1.3을 필수로 사용하여 모든 연결 암호화.
    - **요약:** HTTP/3는 QUIC 프로토콜을 도입하여 연결 설정 속도, 패킷 손실 복원력, 스트림 멀티플렉싱 효율성, 보안을 향상시킴.
